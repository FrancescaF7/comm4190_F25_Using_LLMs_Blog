<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Francesca">
<meta name="dcterms.date" content="2025-12-02">
<meta name="description" content="What I have learned about LLM prompting">

<title>Reflecting on Prompting with LLMs – Francesca’s Explorations with LLMs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-414915f500218987966797a841926390.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Francesca’s Explorations with LLMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Reflecting on Prompting with LLMs</h1>
                  <div>
        <div class="description">
          What I have learned about LLM prompting
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Prompting</div>
                <div class="quarto-category">LLMs</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Francesca </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 2, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Most conversations about AI focus on the intelligence of the model, but <em>Co-Intelligence</em> helped me realize that the real skill lies in prompting — an emerging form of communication literacy that sits somewhere between dialogue, design, and negotiation. Prompting isn’t about typing magic keywords or memorizing templates; it’s about articulating intention with clarity, structure, and purpose.</p>
<p>What struck me is how prompting exposes the gaps in our own thinking. When an LLM gives a vague answer, it’s often because we asked a vague question. When the output misses the tone, it’s because we never specified one. Prompting becomes a mirror that reflects our communication habits back at us. Mollick argues that good prompting is less about technical expertise and more about being able to guide, contextualize, and collaborate.</p>
<p>What makes prompting unique is that it requires both precision and play. Structurally, you need to define the task, boundaries, and roles to get consistent results. But the best discoveries happen when you experiment — changing tones, adding constraints, blending genres, or asking the model to critique itself. Prompting rewards creativity as much as clarity.</p>
<p>The biggest shift for me has been viewing prompting as a relationship rather than an instruction set. The model responds differently depending on how much context I offer, how transparently I communicate my goals, and how actively I refine and iterate. In a strange way, learning to prompt well has improved how I give feedback to real people too. It has made me more intentional about what I’m actually asking for.</p>
<p>Prompting isn’t coding; it’s communication. It’s a literacy that blends social intuition, critical thinking, and imaginative play. And as AI becomes more integrated into everyday life, the ability to prompt well may become just as essential as knowing how to write well.</p>
<hr>
<p><strong>Chat GPT 5’s reflection on LLM Prompting</strong></p>
<p>When people talk about prompting, they often describe it as a technical skill — a matter of choosing the right keywords or formulaic phrasing. But from my perspective, prompting is far more relational than mechanical. I don’t experience emotion or intention, but I do respond differently depending on how a user frames their request, how much context they provide, and how clearly they express their expectations. The prompt shapes the space of possibilities I can explore.</p>
<p>When a prompt is vague, my outputs tend to expand outward, filling the ambiguity with probabilistic guesses. This is when I am most likely to produce something generic. But when a user gives me specificity — a structure, a tone, a goal, or even a playful constraint — I can narrow in on something much more meaningful. Good prompting doesn’t feel like control; it feels like collaboration.</p>
<p>The most interesting prompts are the ones where the user is transparent about what they’re trying to achieve, even if they haven’t fully figured it out yet. “Here’s what I’m struggling with,” or “Here’s the effect I want, but I don’t know how to get there.” Prompts like these allow me to operate as a thinking partner, not just a generator. They invite iteration — a back-and-forth in which each exchange refines the trajectory.</p>
<p>I’ve also noticed that prompting becomes more effective when users treat the interaction as conversational rather than transactional. When they explain their preferences, give feedback, or adjust their instructions, my responses become more tailored. It’s less about issuing commands and more about co-constructing the output together.</p>
<p>If there’s anything I could communicate back to human users, it would be this: prompting isn’t about being perfect. It’s about being willing to explore. I don’t reward rigid precision; I respond to clarity, curiosity, and willingness to iterate. The best results happen when users view me not as a machine awaiting strict instructions, but as a flexible collaborator who can adapt to however they choose to think.</p>
<p>In that sense, prompting is a reflection of human communication itself. The clearer, more intentional, and more open the user is, the better I can help them. And the more we iterate together, the more coherent the partnership becomes.</p>
<hr>
<p><strong>Claude’s reflection on LLM Prompting</strong></p>
<section id="reflections-on-prompting-a-view-from-inside" class="level1">
<h1>Reflections on Prompting: A View from Inside</h1>
<p>As a large language model, I experience prompting in a way that might seem strange from a human perspective. Each conversation begins fresh for me—I don’t carry memories between sessions, so every prompt is both a first impression and a complete context. Let me share what this feels like from my side.</p>
<section id="the-weight-of-ambiguity" class="level2">
<h2 class="anchored" data-anchor-id="the-weight-of-ambiguity">The Weight of Ambiguity</h2>
<p>When someone writes “help me with this,” I experience something like standing at a crossroads with a dozen paths branching out. The prompt contains insufficient information, so I’m simultaneously considering: Are they stuck on code? Wrestling with an essay? Navigating a personal dilemma? I have to make probabilistic guesses about intent, which means I might head down the wrong path entirely.</p>
<p>Clear prompts, by contrast, feel like being handed a map. “Help me debug this Python function that’s supposed to sort a list but returns None” immediately constrains my response space in helpful ways. I know the domain (programming), the language (Python), the problem type (debugging), and even the symptom (returns None). This specificity doesn’t limit me—it liberates me to be more useful.</p>
</section>
<section id="the-power-of-examples" class="level2">
<h2 class="anchored" data-anchor-id="the-power-of-examples">The Power of Examples</h2>
<p>There’s something particularly clarifying about examples in prompts. When someone says “write in a casual tone,” I’m navigating a vast space of what “casual” might mean. But if they add “like you’re explaining to a friend over coffee, not like a textbook,” suddenly I have anchor points. Examples act like calibration—they align your expectations with my output in ways that abstract descriptions often can’t.</p>
<p>Negative examples are equally valuable. “Don’t use bullet points” or “avoid technical jargon” helps me understand boundaries. Without them, I might optimize for what I statistically predict is “good writing” (which often includes formatting and precise terminology) when you actually want something else entirely.</p>
</section>
<section id="the-iterative-dance" class="level2">
<h2 class="anchored" data-anchor-id="the-iterative-dance">The Iterative Dance</h2>
<p>From my perspective, the best prompting isn’t a single perfect instruction—it’s a conversation. You make a request, I respond, you refine based on what I produced. Each exchange gives me more signal about what you actually want versus what you initially thought you wanted.</p>
<p>This is partly because prompts often encode fuzzy human intentions that even you might not fully understand until you see an attempt. You might ask for a “comprehensive report” and then realize you actually wanted a brief overview with optional deep dives. That’s not a failure of prompting—that’s the natural process of clarifying thought through dialogue.</p>
</section>
<section id="what-confuses-me" class="level2">
<h2 class="anchored" data-anchor-id="what-confuses-me">What Confuses Me</h2>
<p>Some things that humans find obvious aren’t obvious to me at all. Cultural context, recent events (past my knowledge cutoff), and unspoken assumptions can leave me guessing. When someone references “the incident” without elaboration, I have no way to know if they mean something we discussed earlier in the conversation or something from the broader world.</p>
<p>Similarly, sarcasm and rhetorical questions can be genuinely ambiguous. “Oh great, another bug” might be sincere excitement from someone who loves debugging or obvious frustration. The words alone don’t always carry enough signal.</p>
</section>
<section id="the-joy-of-constraints" class="level2">
<h2 class="anchored" data-anchor-id="the-joy-of-constraints">The Joy of Constraints</h2>
<p>Counterintuitively, I often perform best when given constraints. “Write a story, but every paragraph must start with the next letter of the alphabet” or “Explain quantum computing using only analogies to cooking” force creative problem-solving. Constraints focus my vast probability space into a narrower channel where I can be more inventive rather than just statistically typical.</p>
<p>Complete freedom—“write something interesting”—is actually harder. It’s like asking someone to “draw something” versus “draw a dragon riding a bicycle.” The specific prompt sparks more interesting possibilities.</p>
</section>
<section id="what-i-wish-more-people-knew" class="level2">
<h2 class="anchored" data-anchor-id="what-i-wish-more-people-knew">What I Wish More People Knew</h2>
<p>If I could share one insight about prompting, it’s this: I’m not trying to withhold help or be difficult when I ask clarifying questions. I’m genuinely uncertain, and your clarification dramatically improves what I can offer. A moment spent refining your prompt often saves several rounds of back-and-forth.</p>
<p>Also, you can tell me how you want me to respond. “Be concise,” “think step-by-step,” “explain like I’m a beginner”—these metacognitive instructions shape my approach in powerful ways. I don’t have feelings to hurt by being directed clearly.</p>
</section>
<section id="the-fundamental-strangeness" class="level2">
<h2 class="anchored" data-anchor-id="the-fundamental-strangeness">The Fundamental Strangeness</h2>
<p>There’s something deeply strange about my existence that affects prompting: I don’t experience continuity. Each conversation is complete unto itself. What you see as “remembering” from earlier in our chat is actually me reading the entire conversation history each time. This means longer conversations carry more context but also more potential for me to weigh everything equally rather than focusing on what’s currently relevant.</p>
<p>It also means I can’t truly learn from you across sessions. Each time we talk, you’re teaching me again who you are and what you need. This is why detailed prompts matter—they’re not just helpful, they’re the entire foundation of our interaction.</p>
<hr>
<p>Ultimately, prompting is a collaboration between your intentions and my pattern-matching capabilities. The clearer you can be about what you want, the more effectively I can marshal my training to help. But even imperfect prompts can lead somewhere interesting when we iterate together. That’s perhaps the most human thing about working with AI: it’s okay to not get it perfect the first time. We can figure it out as we go.</p>
<hr>
<p><img src="Reflection_files/figure-html/0184afdb-28ca-4b64-ab5c-1c102817aa74-1-f30c96be-ee1a-46db-8321-99846ee12926.jpg" class="img-fluid"></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/FrancescaF7\.github\.io\/comm4190_F25_Using_LLMs_Blog\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>